.Model Tiny

.data
ORG	00
; KEYPAD LOOKUP TABLE
KEYPAD_TABLE	DW	3DEh, 3DDh, 3DBh, 3D7h, 3CFh, 3BEh, 3BDh, 3BBh, 3B7h, 3AFh, 37Eh, 37Dh, 37Bh, 377h, 36Fh, 2FEh, 2FDh, 2FBh, 2F7h, 2EFh, 1FEh, 1FDh, 1FBh, 1F7h, 1EFh
KEYPAD_TABLE_LENGTH	EQU	25

; PORT ADDRESSES OF 8255
PORTA_ADDR	EQU	00h
PORTB_ADDR	EQU	02h
PORTC_ADDR	EQU	04h
CTRL_ADDR	EQU	06h
PORTA EQU 10H
PORTB EQU 12H
CMD_REG EQU 16H

; KEYPAD INTERFACE OUTPUT
KEYPRESSED	DB	?
DELAY20MSCOUNT	EQU	7D00h

; LCD OUTPUT BUFFER
LCDOUTPUT	DB	17 DUP(0)

; LCD PROMPTS
STR_SYSTEMREADY	DB	'SYSTEM READY$'
STR_SELECTMODE	DB	'SELECT MODE$'
STR_CONFIRMTRANS	DB	'ENTER TRANS Y/N?$'
STR_CONFIRMADDITEM	DB	'CONFIRM ADD Y/N?$'
STR_CONFIRMDELITEM	DB	'CONFIRM DEL Y/N?$'

; KEY IDs
KEYID_Y		EQU 	10
KEYID_N		EQU	11
KEYID_ENTER	EQU	12
KEYID_BACKSPACE	EQU	13
KEYID_CANCEL	EQU	14
KEYID_ITEMNO	EQU	15
KEYID_QUANTITY	EQU	16
KEYID_TOTAL	EQU	17
KEYID_MODE	EQU	18
KEYID_TRANS	EQU	19
KEYID_PROGRAM	EQU	20
KEYID_ADDITEM	EQU	21
KEYID_DELITEM	EQU	22
KEYID_COST	EQU	23

; TRANSACTION MODE
ITEMCODE_DIG1	DB	?
ITEMCODE_DIG2	DB	?
QUANTITY_NUM	DB	?
TRANS_TOTAL	DW	0

; PROGRAM MODE
PROG_ITEMCODE_DIG1	DB	?
PROG_ITEMCODE_DIG2	DB	?
PROG_ITEMPRICE	DB	0
PROG_RECLENGTH	DB	0

; DATABASE
ITEMCODE	DB	50 DUP(0)
ITEMPRICE	DB	25 DUP(0)

; STACK
STACK1		DW	100 DUP(0)
TOP_STACK1	LABEL	WORD
.code
.startup
		LEA	SP, TOP_STACK1
		CALL LCD_INIT
		
		; CHECK IF LOCK IS OPEN. IF YES, PRINT "SYSTEM READY"
		; MOV	AL, 10000000b
		; OUT	16h, AL
		; IN	AL, 14h
		
		; NOP
; X_CHECKLOCK:	AND	AL, 01h								; MASK EVERYTHING EXCEPT LOCK PIN
		; CMP	AL, 0								; CHECK IF HIGH OR NOT
		; JZ	X_CHECKkey_a							; IF LOW, LOCK IS CLOSED
		; JNZ	lock_now_opened
; X_CHECKkey_a:	;check if some key open or not
		; IN	AL, 00h
		; MOV	BL, AL
		; IN	AL, 02h
		; MOV	CL,AL
		; IN	AL, 04h
		
		; CMP	AL, 0FFh
		; JNZ	X_KEYPRESSED_TRUE
; X_KEYPRESSED_CHECKB:	CMP	BL, 0FFh
		; JNZ	X_KEYPRESSED_TRUE
		; CMP	CL, 0FFh
		; JNZ	X_KEYPRESSED_TRUE
		; JZ	X_CHECKLOCK
		
; X_KEYPRESSED_TRUE:	
		; CALL TIME
		; jmp   X_CHECKLOCK
; lock_now_opened:
				
		MOV	CX, 13
		LEA	SI, STR_SYSTEMREADY
		LEA	DI, LCDOUTPUT
		REP	MOVSB
		
		CALL	PRINTLCD
		
		; GET KEY. IF KEY = MODE, THEN PRINT "SELECT MODE". ELSE, GET KEY AGAIN
X_PRESSMODE:	CALL	GETKEY
		MOV	AL, KEYPRESSED
		CMP	AL, KEYID_MODE
		;JNZ	X_PRESSMODE
		
		; PRINT "SELECT MODE" ON LCD
		MOV	CX, 12
		LEA	SI, STR_SELECTMODE
		LEA	DI, LCDOUTPUT
		REP	MOVSB
		
		CALL	PRINTLCD
		
		; GET KEY UNTIL KEY PRESSED IS TRANS/PROG.
X_MODESELECT:	CALL	GETKEY
		MOV	AL, KEYPRESSED
		CMP	AL, KEYID_TRANS
		JZ	X_TRANSMODE
		CMP	AL, KEYID_PROGRAM
		JZ	X_PROGRAMMODE
		JMP	X_MODESELECT
		
X_TRANSMODE:	; TRANS MODE
			; IF TRANS PRESSED, PRINT "Y/N"
			MOV	CX, 17
			LEA	SI, STR_CONFIRMTRANS
			LEA	DI, LCDOUTPUT
			REP	MOVSB
			CALL	PRINTLCD
			
			CALL GETKEY	
			; GET KEY. IF N, GOTO "SELECT MODE". ELSE CONTINUE
			MOV	AL, KEYPRESSED
			CMP	AL, KEYID_N
			JZ	X_PRESSMODE
			CMP	AL, KEYID_Y
			JZ	X_PRESSITEMNO
			JMP	X_TRANSMODE
			

			; RESET TOTAL
			MOV	BX, 0
			MOV	TRANS_TOTAL, BX
			
X_PRESSITEMNO:		; GET KEY UNTIL ITEM CODE IS PRESSED.
			CALL	GETKEY
			MOV	AL, KEYPRESSED
			CMP	AL, KEYID_ITEMNO
			JNZ	X_PRESSITEMNO
			
X_GETITEMCODE:		; GET ITEM CODE.
				; GET KEY = ITEM CODE DIGIT 1
				CALL	GETKEY
				MOV	AL, KEYPRESSED
				;CMP	AL, 10
				;JGE	X_GETITEMCODE
				MOV	ITEMCODE_DIG1, AL
				
X_ITEMCODE_GETKEY2:		; GET KEY
				CALL	GETKEY
				MOV	AL, KEYPRESSED
					; IF KEY = BACKSPACE. GOTO GET ITEM CODE.
					CMP	AL, KEYID_BACKSPACE
					JZ	X_GETITEMCODE
					; IF KEY = CANCEL. GOTO GET ITEM CODE.
					CMP	AL, KEYID_CANCEL
					JZ	X_GETITEMCODE					
					; IF KEY = DIGIT. FIX IT AS DIGIT 2.
					MOV	ITEMCODE_DIG2, AL
					
X_GETITEMNOCONFIRM:		; GET KEY
				CALL	GETKEY
				MOV	AL, KEYPRESSED
					; IF KEY = BACKSPACE. GOTO GET ITEM DIGIT 2.
					CMP	AL, KEYID_BACKSPACE
					JZ	X_ITEMCODE_GETKEY2
					; IF KEY = CANCEL. GOTO GET ITEM CODE.
					CMP	AL, KEYID_CANCEL
					JZ	X_GETITEMCODE
					; IF KEY = ENTER. DONE.
					CMP	AL, KEYID_ENTER
					JNZ	X_GETITEMNOCONFIRM
					MOV	AL, ITEMCODE_DIG1
					ADD	AL, 30h
					MOV	LCDOUTPUT, AL
					MOV	AL, ITEMCODE_DIG2
					ADD	AL, 30h
					MOV	LCDOUTPUT + 1, AL
					MOV	AL, '$'
					MOV	LCDOUTPUT + 2, AL
					CALL	PRINTLCD
			; GOT ITEM CODE AND PRINTED
			
X_GETQUANTITY:		; GET QUANTITY
				CALL	GETKEY
				MOV	AL, KEYPRESSED
				; GET KEY = QUANTITY KEY
				CMP	AL, KEYID_QUANTITY
				JNZ	X_GETQUANTITY
X_GETQUANTITYNUM:		; GET QUANTITY NUMBER
				CALL	GETKEY
				MOV	AL, KEYPRESSED
				MOV	QUANTITY_NUM, AL
X_GETQUANTITYCONFIRM:		; GET KEY
				CALL	GETKEY
				MOV	AL, KEYPRESSED
					; IF KEY = BACKSPACE. GOTO GET QUANTITY NUMBER
					CMP	AL, KEYID_BACKSPACE
					JZ	X_GETQUANTITYNUM
					; IF KEY = CANCEL. GOTO GET ITEM CODE
					CMP	AL, KEYID_CANCEL
					JZ	X_GETITEMCODE
					; IF KEY = ENTER. PROCEED.
					CMP	AL, KEYID_ENTER
					JNZ	X_GETQUANTITYCONFIRM
			; GOT QUANTITY
			
			; CALCULATE COST OF ITEM AND UPDATE TOTAL
			LEA	SI, ITEMCODE
			MOV	CL, PROG_RECLENGTH
			MOV	CH, 0
			MOV	AH, ITEMCODE_DIG1
			MOV	AL, ITEMCODE_DIG2
			
X_TRANS_LOOP:		CMP	[SI], AH
			JNZ	X_TRANS_FIRSTUNMATCH
			JZ	X_TRANS_FIRSTMATCH
			
X_TRANS_FIRSTUNMATCH:	ADD	SI, 2
			DEC	CX
			JNZ	X_TRANS_LOOP
			JZ	X_TRANS_LOOPEND
			
X_TRANS_FIRSTMATCH:	INC	SI
			CMP	[SI], AL
			JZ	X_TRANS_LOOPEND
			INC	SI
			DEC	CX
			JNZ	X_TRANS_LOOP
			JZ	X_TRANS_LOOPEND
			
X_TRANS_LOOPEND:	DEC	SI
			MOV	AL, PROG_RECLENGTH
			MOV	AH, 0
			SUB	AX, CX
			LEA	SI, ITEMPRICE
			ADD	SI, AX
			MOV	AL, [SI]							; AL HAS PRICE OF ITEM NEEDED

			MOV	BL, QUANTITY_NUM
			MUL	BL								; CURRENT ITEM COST IN AX
			MOV	BX, TRANS_TOTAL
			ADD	BX, AX
			MOV	TRANS_TOTAL, BX
			
			; PRINT COST ON LCD
				; SET HIGHER DIGIT
				MOV	BX, AX
				AND	BX, 00F0h
				MOV 	CL, 04
				SHR	BX, CL
				ADD	BL, 30h
				CMP	BL, 3Ah
				JBE	X_TRANS_PRINTCOST_SET1
				ADD	BL, 7				
X_TRANS_PRINTCOST_SET1: 	MOV	LCDOUTPUT, BL
				; SET LOWER DIGIT
				MOV	BX, AX
				AND	BX, 000Fh
				ADD	BL, 30h
				CMP	BL, 3Ah
				JBE	X_TRANS_PRINTCOST_SET2
				ADD	BL, 7				
X_TRANS_PRINTCOST_SET2: 	MOV	LCDOUTPUT + 1, BL
				; SET END NULL CHARACTER
				MOV	AL, '$'
				MOV	LCDOUTPUT + 2, AL
			CALL	PRINTLCD
				
			; GET KEY
			CALL	GETKEY
			MOV	AL, KEYPRESSED
				; IF KEY != TOTAL. GOTO "PRESS ITEM NUMBER" KEY
				CMP	AL, KEYID_TOTAL
				JNZ	X_PRESSITEMNO
				; ELSE PRINT TOTAL
					; SET DIGIT 1
					MOV	BX, AX
					AND	BX, 0F000h
					MOV 	CL, 12
					SHR	BX, CL
					ADD	BL, 30h
					CMP	BL, 3Ah
					JBE	X_TRANS_PRINTTOTALCOST_SET1
					ADD	BL, 7				
X_TRANS_PRINTTOTALCOST_SET1:	 	MOV	LCDOUTPUT, BL

					; SET DIGIT 2
					MOV	BX, AX
					AND	BX, 0F00h
					MOV 	CL, 8
					SHR	BX, CL
					ADD	BL, 30h
					CMP	BL, 3Ah
					JBE	X_TRANS_PRINTTOTALCOST_SET2
					ADD	BL, 7				
X_TRANS_PRINTTOTALCOST_SET2:	 	MOV	LCDOUTPUT + 1, BL
					
					; SET DIGIT 3
					MOV	BX, AX
					AND	BX, 00F0h
					MOV 	CL, 4
					SHR	BX, CL
					ADD	BL, 30h
					CMP	BL, 3Ah
					JBE	X_TRANS_PRINTTOTALCOST_SET3
					ADD	BL, 7				
X_TRANS_PRINTTOTALCOST_SET3:	 	MOV	LCDOUTPUT + 2, BL

					; SET DIGIT 4
					MOV	BX, AX
					AND	BX, 000Fh
					ADD	BL, 30h
					CMP	BL, 3Ah
					JBE	X_TRANS_PRINTTOTALCOST_SET4
					ADD	BL, 7				
X_TRANS_PRINTTOTALCOST_SET4:	 	MOV	LCDOUTPUT + 3, BL

					; SET END NULL CHARACTER
					MOV	AL, '$'
					MOV	LCDOUTPUT + 4, AL
				CALL	PRINTLCD
			; GOT TRANS LAST KEY
			
		; END OF TRANSACTION MODE
		
		; JUMP TO SELECT MODE
		JMP	X_PRESSMODE
		
X_PROGRAMMODE:	; PROG MODE
			; GET KEY
X_PROG_CHOOSEACTION:	; IF KEY = "ADD ITEM", GOTO ADD ITEM CODE. IF KEY = "DEL ITEM", GOTO DEL ITEM CODE.
			CALL	GETKEY
			MOV	AL, KEYPRESSED
			CMP	AL, KEYID_ADDITEM
			JZ	X_PROG_ADDITEM
			CMP	AL, KEYID_DELITEM
			JZ	X_PROG_DELITEM
			JMP	X_PROG_CHOOSEACTION
			
X_PROG_ADDITEM:		; ADD ITEM CODE

X_PROG_PRESSITEMNO:	; GET KEY UNTIL ITEM CODE IS PRESSED.
			CALL	GETKEY
			MOV	AL, KEYPRESSED
			CMP	AL, KEYID_ITEMNO
			JNZ	X_PROG_PRESSITEMNO			
			
X_PROG_GETITEMCODE:	; GET ITEM CODE.
				; GET KEY = ITEM CODE DIGIT 1
				CALL	GETKEY
				MOV	AL, KEYPRESSED
				;CMP	AL, 10
				;JGE	X_GETITEMCODE
				MOV	PROG_ITEMCODE_DIG1, AL
				
X_PROG_ITEMCODE_GETKEY2:	; GET KEY
				CALL	GETKEY
				MOV	AL, KEYPRESSED
					; IF KEY = BACKSPACE. GOTO GET ITEM CODE.
					CMP	AL, KEYID_BACKSPACE
					JZ	X_PROG_GETITEMCODE
					; IF KEY = CANCEL. GOTO GET ITEM CODE.
					CMP	AL, KEYID_CANCEL
					JZ	X_PROG_GETITEMCODE					
					; IF KEY = DIGIT. FIX IT AS DIGIT 2.
					MOV	PROG_ITEMCODE_DIG2, AL
					
X_PROG_GETITEMNOCONFIRM:	; GET KEY
				CALL	GETKEY
				MOV	AL, KEYPRESSED
					; IF KEY = BACKSPACE. GOTO GET ITEM DIGIT 2.
					CMP	AL, KEYID_BACKSPACE
					JZ	X_PROG_ITEMCODE_GETKEY2
					; IF KEY = CANCEL. GOTO GET ITEM CODE.
					CMP	AL, KEYID_CANCEL
					JZ	X_PROG_GETITEMCODE
					; IF KEY = ENTER. DONE.
					CMP	AL, KEYID_ENTER
					JNZ	X_PROG_GETITEMNOCONFIRM
					MOV	AL, PROG_ITEMCODE_DIG1
					ADD	AL, 30h
					MOV	LCDOUTPUT, AL
					MOV	AL, PROG_ITEMCODE_DIG2
					ADD	AL, 30h
					MOV	LCDOUTPUT + 1, AL
					MOV	AL, '$'
					MOV	LCDOUTPUT + 2, AL
					CALL	PRINTLCD
			; GOT ITEM CODE AND PRINTED
			
			; GET COST KEY PRESS
X_PROG_PRESSCOST:	CALL	GETKEY
			MOV	AL, KEYPRESSED
			CMP	AL, KEYID_COST
			JNZ	X_PROG_PRESSCOST
				
			; GET COST
			CALL	GETKEY
			MOV	AL, KEYPRESSED
			;CMP	AL, 10
			;JGE	X_GETITEMCODE
			MOV	PROG_ITEMPRICE, AL
			
			; GET KEY = ENTER AND DISPLAY CONFIRM MESSAGE
X_ADDITEM_PRICECONFIRM:	CALL	GETKEY
			MOV	AL, KEYPRESSED
			CMP	AL, KEYID_ENTER
			JNZ	X_ADDITEM_PRICECONFIRM
			
			; PRINT CONFIRM MESSAGE ON LCD
			MOV	CX, 17
			LEA	SI, STR_CONFIRMADDITEM
			LEA	DI, LCDOUTPUT
			REP	MOVSB
			CALL	PRINTLCD
			
			; GET KEY
			; IF KEY = Y. PRINT MESSAGE "CONFIRM".
			; IF KEY = N. GOTO PROGRAM MODE GET KEY
X_PROG_CONFIRMADDITEM:	CALL	GETKEY
			MOV	AL, KEYPRESSED
			CMP	AL, KEYID_N
			JZ	X_PROGRAMMODE
			CMP	AL, KEYID_Y
			JNZ	X_PROG_CONFIRMADDITEM
			
			; STORE RECORD IN MEMORY
			; STORE ITEM CODE
			MOV	CL, PROG_RECLENGTH
			MOV	CH, 0
			MOV	BX, CX
			ADD	CX, BX
			LEA	DI, ITEMCODE
			ADD	DI, CX
			MOV	AL, PROG_ITEMCODE_DIG1
			MOV	[DI], AL
			INC	DI
			MOV	AL, PROG_ITEMCODE_DIG2
			MOV	[DI], AL
			; STORE PRICE
			LEA	DI, ITEMPRICE
			ADD	DI, CX
			MOV	AL, PROG_ITEMPRICE
			MOV	[DI], AL
			; UPDATE NUMBER OF RECORDS
			INC	CX
			MOV	PROG_RECLENGTH, CL
			; JUMP TO SELECT MODE. MUST PRESS MODE KEY
			JMP	X_PRESSMODE
			
			; END OF ADD ITEM
			
X_PROG_DELITEM:		; ELSE IF KEY = DEL ITEM KEY
			
			; GET ITEMNO KEY PRESS
X_PROG_DELITEM_PRESSITEMNO:	CALL	GETKEY
			MOV	AL, KEYPRESSED
			CMP	AL, KEYID_ITEMNO
			JNZ	X_PROG_DELITEM_PRESSITEMNO
			
X_PROG_DELITEM_GETITEMCODE:	; GET ITEM CODE.
				; GET KEY = ITEM CODE DIGIT 1
				CALL	GETKEY
				MOV	AL, KEYPRESSED
				;CMP	AL, 10
				;JGE	X_GETITEMCODE
				MOV	PROG_ITEMCODE_DIG1, AL
				
X_PROG_DELITEM_ITEMCODE_GETKEY2:; GET KEY
				CALL	GETKEY
				MOV	AL, KEYPRESSED
					; IF KEY = BACKSPACE. GOTO GET ITEM CODE.
					CMP	AL, KEYID_BACKSPACE
					JZ	X_PROG_DELITEM_GETITEMCODE
					; IF KEY = CANCEL. GOTO GET ITEM CODE.
					CMP	AL, KEYID_CANCEL
					JZ	X_PROG_DELITEM_GETITEMCODE					
					; IF KEY = DIGIT. FIX IT AS DIGIT 2.
					MOV	PROG_ITEMCODE_DIG2, AL
					
X_PROG_DELITEM_GETITEMNOCONFIRM:; GET KEY
				CALL	GETKEY
				MOV	AL, KEYPRESSED
					; IF KEY = BACKSPACE. GOTO GET ITEM DIGIT 2.
					CMP	AL, KEYID_BACKSPACE
					JZ	X_PROG_DELITEM_ITEMCODE_GETKEY2
					; IF KEY = CANCEL. GOTO GET ITEM CODE.
					CMP	AL, KEYID_CANCEL
					JZ	X_PROG_DELITEM_GETITEMCODE
					; IF KEY = ENTER. DONE.
					CMP	AL, KEYID_ENTER
					JNZ	X_PROG_DELITEM_GETITEMNOCONFIRM
					; PRINT CONFIRM MESSAGE ON LCD
					MOV	CX, 17
					LEA	SI, STR_CONFIRMDELITEM
					LEA	DI, LCDOUTPUT
					REP	MOVSB
					CALL	PRINTLCD
			; GOT ITEM CODE AND PRINTED CONFIRM MESSAGE
			
			; GET KEY
X_PROG_DELITEM_GETCONFIRM:CALL	GETKEY
			MOV	AL, KEYPRESSED
			
			CMP	AL, KEYID_N
			JZ	X_PROG_CHOOSEACTION
			CMP	AL, KEYID_Y
			JNZ	X_PROG_DELITEM_GETCONFIRM
			
			; DELETE ITEM FROM DATABASE
			LEA	SI, ITEMCODE
			MOV	CL, PROG_RECLENGTH
			MOV	CH, 0
			MOV	AH, PROG_ITEMCODE_DIG1
			MOV	AL, PROG_ITEMCODE_DIG2
			
X_PROG_DELITEM_LOOP:	CMP	[SI], AH
			JNZ	X_DEL_FIRSTUNMATCH
			JZ	X_DEL_FIRSTMATCH
			
X_DEL_FIRSTUNMATCH:	ADD	SI, 2
			DEC	CX
			JNZ	X_PROG_DELITEM_LOOP
			JZ	X_PROG_DELITEM_LOOPEND
			
X_DEL_FIRSTMATCH:	INC	SI
			CMP	[SI], AL
			JZ	X_PROG_DELITEM_LOOPEND
			INC	SI
			DEC	CX
			JNZ	X_PROG_DELITEM_LOOP
			JZ	X_PROG_DELITEM_LOOPEND
			
X_PROG_DELITEM_LOOPEND:	MOV	BL, 0
			DEC	SI
			MOV	[SI], BL
			MOV	[SI + 1], BL
			MOV	AL, PROG_RECLENGTH
			MOV	AH, 0
			SUB	AX, CX
			LEA	SI, ITEMPRICE
			ADD	SI, AX
			MOV	[SI], BL
		; END OF PROG MODE.

		; JUMP TO SELECT MODE
		JMP	X_PRESSMODE
.exit

; KEYPAD INTERFACING		

GETKEY		PROC	NEAR
		
		PUSHF
		PUSH	AX
		PUSH	BX
		PUSH	CX
		PUSH	DX
		
		; INITIALIZE CONTROL REGISTER
		MOV	AL, 10011011b							; PORT C INITIALIZED AS INPUT
		OUT	CTRL_ADDR, AL
		
X_KEY_START:
		IN	AL, 02h
		MOV BL,AL
		IN	AL, 04h
		MOV CL,AL
		IN	AL, 00h
		
		CMP	AL, 0FFh
		JZ	X_KEY_PORTB
		JNZ	X_KEY_PORTA_SET
X_KEY_PORTB:	CMP	BL, 0FFh
		JZ	X_KEY_PORTC
		JNZ	X_KEY_PORTB_SET
X_KEY_PORTC:	CMP	CL, 0FFh
		JZ	X_KEY_START
		JNZ	X_KEY_PORTC_SET
		
		
		; SET PORT A KEY
X_KEY_PORTA_SET:
		MOV	DL, 1
		MOV	DH, 0
		
X_PORTA_TEST:	MOV	AH, AL
		AND	AH, 01h
		CMP	AH, 0
		JNZ	X_A
		JZ	Y_A
		
X_A:	MOV CL, DL
		SHR	AL, CL
		INC	DH
		JMP	X_PORTA_TEST
		
Y_A:		MOV	KEYPRESSED, DH
		JMP	X_KEY_RET
		
		; SET PORT B KEY
X_KEY_PORTB_SET:
		MOV	DL, 1
		MOV	DH, 0
		
X_PORTB_TEST:	MOV	BH, BL
		AND	BH, 01h
		CMP	BH, 0
		JNZ	X_B
		JZ	Y_B
		
X_B:	MOV CL, DL
		SHR	BL, CL
		INC	DH
		JMP	X_PORTB_TEST
		
Y_B:		ADD	DH, 8
		MOV	KEYPRESSED, DH
		JMP	X_KEY_RET
		
		; SET PORT C KEY
X_KEY_PORTC_SET:
		MOV	DL, 1
		MOV	DH, 0
		
X_PORTC_TEST:	MOV	CH, CL
		AND	CH, 01h
		CMP	CH, 0
		JNZ	X_C
		JZ	Y_C
		
X_C:	MOV BL,CL
		MOV CL,DL
		SHR	BL, CL
		MOV CL,BL
		INC	DH
		JMP	X_PORTB_TEST
		
Y_C:		ADD	DH, 16
		MOV	KEYPRESSED, DH
		JMP	X_KEY_RET
		
X_KEY_RET:	POP	DX
		POP	CX
		POP	BX
		POP	AX
		POPF
		
		RET
GETKEY ENDP

; DELAY FUNCTION FOR KEYPAD INTERFACING
DELAY_20MS	PROC	NEAR
		PUSHF
		PUSH	AX
		PUSH	BX
		PUSH	CX
		PUSH	DX
		
		MOV	CX, DELAY20MSCOUNT						; MACHINE CYCLES COUNT FOR 20ms
X_DELAYLOOP:	NOP
		NOP
		NOP
		NOP
		NOP
		LOOP	X_DELAYLOOP
		
		POP	DX
		POP	CX
		POP	BX
		POP	AX
		POPF
		
		RET
DELAY_20MS	ENDP

; PROCEDURE TO PRINT LCD OUTPUT
PRINTLCD	PROC	NEAR
		PUSHF
		PUSH	AX
		PUSH	BX
		PUSH	CX
		PUSH	DX
		
		MOV AL,80H
		OUT 10H,AL
		CALL CLS
		CALL WRITE_MEM
		
		POP	DX
		POP	CX
		POP	BX
		POP	AX
		POPF
		
		RET
PRINTLCD	ENDP

LCD_INIT PROC NEAR
		MOV AL,80H
		OUT 10H,AL
		MOV AL, 38H 
		CALL COMNDWRT 
		CALL DELAY 
		CALL DELAY 
		CALL DELAY
		MOV AL, 0EH 
		CALL COMNDWRT
		CALL DELAY
		MOV AL, 01  
		CALL COMNDWRT
		CALL DELAY
		MOV AL, 06  
		CALL COMNDWRT
		CALL DELAY
		RET
LCD_INIT ENDP

CLS PROC 
		MOV AL, 01  
		CALL COMNDWRT
		CALL DELAY
		CALL DELAY
		RET
CLS ENDP


COMNDWRT PROC 
		MOV DX, PORTA
		OUT DX, AL
		MOV DX, PORTB 
		MOV AL, 00000100B 
		OUT DX, AL
		NOP
		NOP
		MOV AL, 00000000B 
		OUT DX, AL
		RET
COMNDWRT ENDP

WRITE_MEM PROC NEAR 
		LEA DI,LCDOUTPUT
		CALL CLS
		MOV SI,16
X10:	MOV AL, [DI] 
		CALL DATWRIT 
		CALL DELAY 
		CALL DELAY 
		INC DI
		DEC SI
		JNZ X10
		RET
WRITE_MEM ENDP	

DATWRIT PROC
		MOV DX,PORTA  
		OUT DX, AL
		MOV AL, 00000101B 
		MOV DX, PORTB
		OUT DX, AL  
		MOV AL, 00000001B
		OUT DX, AL
		RET
DATWRIT ENDP



DELAY PROC
MOV CX, 1325 
W1: 
		NOP
		NOP
		NOP
		NOP
		NOP
		LOOP W1
		RET
DELAY ENDP


TIME PROC NEAR USES AX DX

		MOV DX,26H
		MOV AL,00110110B
		OUT DX,AL

		MOV AL,01110000B
		OUT DX,AL

		MOV AL,10110110B
		OUT DX,AL

		MOV DX,20H
		MOV AX,15000
		OUT DX,AX
		MOV AX,0
		OUT DX,AX

		MOV DX,22H
		MOV AX,8000
		OUT DX,AX
		MOV AL,0
		OUT DX,AL

		MOV DX,24H
		MOV AX,500
		OUT DX,AX
		MOV AX,0
		OUT DX,AX

		RET
TIME ENDP
		;lock open


END